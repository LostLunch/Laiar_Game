<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 채팅</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; }
        #chat-messages::-webkit-scrollbar { width: 8px; }
        #chat-messages::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb:hover { background: #555; }
        #rolling-cat-container {
            position: fixed;
            bottom: 10px;
            left: 0;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: rollAcross 20s linear infinite;
        }
        #cat-emoji { 
            font-size: 40px;
            /* [추가] 이미지로 부드럽게 전환되기 위해 크기 설정 */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #cat-name {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 5px;
            white-space: nowrap;
        }
        @keyframes rollAcross {
            0% { transform: translateX(-100px) rotate(0deg); }
            100% { transform: translateX(100vw) rotate(1800deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex items-center justify-center min-h-screen">
    <div class="w-full max-w-2xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col h-[80vh] max-h-[700px]">

            <!-- 방 선택 화면 -->
            <div id="room-selection" class="flex flex-col items-center justify-center h-full">
                <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-4">실시간 채팅</h1>
                <p class="text-gray-600 dark:text-gray-400 mb-8 text-center">친구와 대화를 시작해보세요.</p>
                <div class="w-full max-w-sm flex flex-col items-center gap-4">
                    <div class="w-full">
                        <label for="room-id-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 text-center">기존 방 참여하기</label>
                        <div class="flex gap-2">
                            <input id="room-id-input" type="text" placeholder="방 ID를 입력하세요" class="flex-1 p-3 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg text-center" disabled/>
                            <button id="join-existing-room-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-400" disabled>참여</button>
                        </div>
                    </div>
                    <div class="my-2 flex items-center w-full"><hr class="w-full border-gray-300 dark:border-gray-600"><span class="px-4 text-gray-500">또는</span><hr class="w-full border-gray-300 dark:border-gray-600"></div>
                    <button id="create-new-room-btn" class="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 disabled:bg-gray-400" disabled>새로운 방 만들기</button>
                </div>
                 <p id="auth-status" class="mt-8 text-sm text-gray-500 dark:text-gray-400">인증 중...</p>
            </div>


            <!-- 채팅방 화면 -->
            <div id="chat-room" class="hidden flex-1 flex-col min-h-0">
                <div class="mb-4">
                     <div class="flex justify-between items-center">
                        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">사람 찾기 게임</h1>
                        <button id="leave-room-btn" class="text-sm text-red-500 hover:underline">나가기</button>
                     </div>
                    <p class="text-sm text-gray-500 dark:text-gray-400 break-all">방 ID: <span id="room-id-display" class="font-mono"></span></p>
                    <div id="role-display" class="text-sm font-semibold mt-2"></div>
                    <div id="game-word-display" class="hidden mb-3 p-3 bg-yellow-100 dark:bg-yellow-900 border border-yellow-300 dark:border-yellow-600 rounded-lg">
                        <div class="text-sm font-semibold text-yellow-800 dark:text-yellow-200 mb-1">제시어</div>
                        <div id="current-word" class="text-lg font-bold text-yellow-900 dark:text-yellow-100"></div>
                    </div>
                    <div id="game-status" class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                        5명의 용의자 중 1명은 진짜 사람입니다. 누가 진짜 사람인지 찾아보세요!
                    </div>
                    <div id="participants-info" class="text-xs text-gray-500 dark:text-gray-400 mt-2"></div>
                </div>
                <div id="chat-messages" class="flex-1 overflow-y-auto bg-gray-50 dark:bg-gray-900 p-4 rounded-lg mb-4 border border-gray-200 dark:border-gray-700"></div>
                <div id="operator-input" class="hidden mb-3">
                    <form id="operator-form" class="flex items-center gap-3">
                        <input id="operator-message-input" type="text" placeholder="운영자로서 답변을 입력하세요..." autocomplete="off" class="flex-1 p-3 bg-yellow-50 dark:bg-yellow-900 border border-yellow-300 dark:border-yellow-600 rounded-lg"/>
                        <button id="operator-send-btn" type="submit" class="px-6 py-3 bg-yellow-600 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-700">전송</button>
                    </form>
                </div>
                <form id="message-form" class="flex items-center gap-3">
                    <input id="message-input" type="text" placeholder="질문을 입력하세요..." autocomplete="off" class="flex-1 p-3 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg"/>
                    <button id="send-btn" type="submit" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">질문</button>
                </form>
            </div>
        </div>
    </div>
    
    <div id="rolling-cat-container">
        <div id="cat-name"></div>
        <div id="cat-emoji">🐈</div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove, runTransaction, writeBatch, orderBy, limit, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDMgGwmlV9T8l0CPsMrJ8H0NrTTUNtSDMo",
            authDomain: "text-861c1.firebaseapp.com",
            projectId: "text-861c1",
            storageBucket: "text-861c1.firebasestorage.app",
            messagingSenderId: "521608830043",
            appId: "1:521608830043:web:5df3d118d76ca4562eb37e",
        };
        
        const roomSelection = document.getElementById('room-selection');
        const chatRoom = document.getElementById('chat-room');
        const roomIdInput = document.getElementById('room-id-input');
        const joinExistingRoomBtn = document.getElementById('join-existing-room-btn');
        const createNewRoomBtn = document.getElementById('create-new-room-btn');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const roomIdDisplay = document.getElementById('room-id-display');
        const chatMessages = document.getElementById('chat-messages');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const authStatus = document.getElementById('auth-status');
        const gameStatus = document.getElementById('game-status');
        const roleDisplay = document.getElementById('role-display');
        const participantsInfo = document.getElementById('participants-info');
        const operatorInput = document.getElementById('operator-input');
        const operatorForm = document.getElementById('operator-form');
        const operatorMessageInput = document.getElementById('operator-message-input');
        const operatorSendBtn = document.getElementById('operator-send-btn');
        const gameWordDisplay = document.getElementById('game-word-display');
        const currentWord = document.getElementById('current-word');
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null, currentRoomId = null;
        let unsubscribeMessages = null;
        let currentGameWord = null;
        let gamePhase = 'statement1';
        let isOperator = false; // 방 생성자인지 여부
        let isGameStarted = false;
        let suspectNames = []; // 용의자 이름 배열
        let operatorSuspectIndex = -1; // 운영자가 몇 번 용의자인지
        let waitingForOperatorResponse = false;
        
        function showNotification(message, type = 'error', duration = 3000) {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
            notification.className = `fixed top-5 right-5 ${bgColor} text-white py-2 px-4 rounded-lg shadow-lg z-50`;
            notification.innerHTML = message;
            document.body.appendChild(notification);
            setTimeout(() => { notification.remove(); }, duration);
        }

        onAuthStateChanged(auth, user => {
            if (user) { 
                currentUser = user; 
                [roomIdInput, joinExistingRoomBtn, createNewRoomBtn].forEach(el => el.disabled = false);
                authStatus.textContent = '인증 완룼'; 
                authStatus.classList.add('text-green-500');
                console.log('인증 완료, 버튼 활성화 완료');
            } else { 
                signInAnonymously(auth).catch(err => showNotification("익명 인증 실패: " + err.message));
            }
        });
        

        function generateSuspectNames() {
            // 용의자 이름을 랜덤으로 섬기
            suspectNames = ['용의자 1', '용의자 2', '용의자 3', '용의자 4', '용의자 5'];
            // 배열을 랜덤으로 섬기
            for (let i = suspectNames.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [suspectNames[i], suspectNames[j]] = [suspectNames[j], suspectNames[i]];
            }
            // 운영자가 몇 번 용의자인지 저장 (0~4 인덱스)
            operatorSuspectIndex = Math.floor(Math.random() * 5);
        }

        async function enterChatRoom(roomId, asOperator = false) {
            currentRoomId = roomId; 
            isOperator = asOperator;
            roomIdDisplay.textContent = currentRoomId; 
            roomSelection.classList.add('hidden'); 
            chatRoom.classList.remove('hidden'); 
            chatRoom.classList.add('flex');
            
            // 용의자 이름 생성
            generateSuspectNames();
            
            // 역할 표시
            if (isOperator) {
                roleDisplay.textContent = '당신은 운영자입니다';
                roleDisplay.className = 'text-sm font-semibold mt-2 text-yellow-600 dark:text-yellow-400';
                operatorInput.classList.remove('hidden');
                participantsInfo.textContent = '사용자가 입장하기를 기다리는 중...';
            } else {
                roleDisplay.textContent = '당신은 체험자입니다';
                roleDisplay.className = 'text-sm font-semibold mt-2 text-blue-600 dark:text-blue-400';
                participantsInfo.textContent = `운영자는 ${suspectNames[operatorSuspectIndex]}입니다. (비밀)`;
            }
            
            // 게임 시작 메시지 추가 및 제시어 설정
            if (asOperator) {
                // 제시어 가져오기
                try {
                    const wordResult = await callLiarGameAPI('/api/start_dec');
                    if (wordResult && wordResult.word) {
                        currentGameWord = wordResult.word;
                        currentWord.textContent = currentGameWord;
                        gameWordDisplay.classList.remove('hidden');
                        
                        // 방에 제시어 저장
                        await updateDoc(doc(db, 'chat_rooms', roomId), {
                            currentWord: currentGameWord
                        });
                        
                        await addDoc(collection(db, `chat_rooms/${roomId}/messages`), {
                            text: `사람 찾기 게임에 오신 것을 환영합니다! 제시어는 "${currentGameWord}"입니다. 5명의 용의자 중 1명은 진짜 사람입니다.`,
                            senderId: 'system',
                            timestamp: serverTimestamp()
                        });
                    } else {
                        await addDoc(collection(db, `chat_rooms/${roomId}/messages`), {
                            text: '사람 찾기 게임에 오신 것을 환영합니다! 5명의 용의자 중 1명은 진짜 사람입니다.',
                            senderId: 'system',
                            timestamp: serverTimestamp()
                        });
                    }
                } catch (error) {
                    console.error('제시어 가져오기 실패:', error);
                    await addDoc(collection(db, `chat_rooms/${roomId}/messages`), {
                        text: '사람 찾기 게임에 오신 것을 환영합니다! 5명의 용의자 중 1명은 진짜 사람입니다.',
                        senderId: 'system',
                        timestamp: serverTimestamp()
                    });
                }
            } else {
                // 참가자도 제시어 표시
                // 방에 저장된 제시어 가져오기 시도
                const roomDoc = await getDoc(doc(db, 'chat_rooms', roomId));
                if (roomDoc.exists() && roomDoc.data().currentWord) {
                    currentGameWord = roomDoc.data().currentWord;
                    currentWord.textContent = currentGameWord;
                    gameWordDisplay.classList.remove('hidden');
                }
            }
            
            loadMessages(roomId); 
        }


        joinExistingRoomBtn.addEventListener('click', async () => {
            const roomId = roomIdInput.value.trim(); 
            if (!roomId) return showNotification("방 ID를 입력해주세요.");
            const docSnap = await getDoc(doc(db, 'chat_rooms', roomId));
            if (docSnap.exists()) {
                // 참가자로 입장 (체험자)
                enterChatRoom(roomId, false);
            } else { 
                showNotification("방을 찾을 수 없습니다.");
            }
        });

        createNewRoomBtn.addEventListener('click', async () => {
            const newRoomId = Math.random().toString(36).substring(2, 8);
            await setDoc(doc(db, 'chat_rooms', newRoomId), { 
                createdAt: serverTimestamp(),
                operatorId: currentUser.uid,
                currentWord: null // 제시어는 나중에 설정
            });
            // 운영자로 입장
            enterChatRoom(newRoomId, true);
        });
        
        // API 호출 함수
        async function callLiarGameAPI(endpoint, data = {}) {
            try {
                console.log(`API 호출 시도: ${endpoint}`, data);
                const response = await fetch(`http://127.0.0.1:5000${endpoint}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });
                
                console.log('API 응답 상태:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('API 응답 데이터:', result);
                return result;
            } catch (error) {
                console.error('API 호출 오류:', error);
                showNotification(`API 호출 오류: ${error.message}. 백엔드 서버(http://127.0.0.1:5000)가 실행 중인지 확인하세요.`);
                return null;
            }
        }
        
        async function processGameTurn(userQuestion) {
            try {
                if (!isGameStarted) {
                    // 처음 게임 시작
                    isGameStarted = true;
                    await addDoc(collection(db, `chat_rooms/${currentRoomId}/messages`), {
                        text: '게임이 시작되었습니다! 운영자의 답변을 기다리는 중...',
                        senderId: 'system',
                        timestamp: serverTimestamp()
                    });
                }
                
                // 운영자에게 답변 요청
                if (isOperator) {
                    // 운영자는 답변 입력 창 활성화
                    waitingForOperatorResponse = true;
                    operatorMessageInput.placeholder = `"용의자 ${operatorSuspectIndex + 1}"로서 답변하세요: ${userQuestion}`;
                    showNotification('운영자로서 답변을 입력해주세요.', 'info');
                } else {
                    // 체험자는 운영자 답변을 기다림
                    showNotification('운영자의 답변을 기다리는 중...', 'info');
                }
                
                // AI 응답 생성
                let result;
                let phaseTitle;
                
                if (gamePhase === 'statement1' || gamePhase === 'statement2') {
                    result = await callLiarGameAPI('/api/start_dec');
                    phaseTitle = gamePhase === 'statement1' ? '1차 진술 단계' : '2차 진술 단계';
                    if (result) {
                        currentGameWord = result.word;
                        gamePhase = gamePhase === 'statement1' ? 'discussion1' : 'discussion2';
                    }
                } else if (gamePhase === 'discussion1' || gamePhase === 'discussion2') {
                    result = await callLiarGameAPI('/api/start_disc', { word: currentGameWord });
                    phaseTitle = gamePhase === 'discussion1' ? '1차 토론 단계' : '2차 토론 단계';
                    if (result) {
                        if (gamePhase === 'discussion1') {
                            gamePhase = 'statement2';
                        } else {
                            gamePhase = 'vote';
                        }
                    }
                }
                
                // 운영자 답변을 기다리지 않고 AI 응답만 먼저 저장
                if (result) {
                    const aiResponses = result.declaration_messages || result.discussion_messages;
                    
                    // AI 응답들을 용의자 인덱스와 매핑
                    const responses = [];
                    
                    // AI 4명의 응답 추가 (운영자 인덱스 제외)
                    let aiIndex = 0;
                    for (let i = 0; i < 5; i++) {
                        if (i === operatorSuspectIndex) {
                            // 운영자 자리는 비워두고 나중에 추가
                            responses.push({ 
                                text: '답변 대기 중...', 
                                isOperator: true, 
                                suspectIndex: i 
                            });
                        } else {
                            responses.push({ 
                                text: aiResponses[aiIndex], 
                                isOperator: false, 
                                suspectIndex: i 
                            });
                            aiIndex++;
                        }
                    }
                    
                    // 임시 저장 (운영자 답변 대기 중)
                    await addDoc(collection(db, `chat_rooms/${currentRoomId}/temp_responses`), {
                        responses: responses,
                        phaseTitle: phaseTitle,
                        questionId: Date.now(), // 질문 ID
                        timestamp: serverTimestamp()
                    });
                }
                
            } catch (error) {
                console.error('게임 처리 오류:', error);
                await addDoc(collection(db, `chat_rooms/${currentRoomId}/messages`), {
                    text: `게임 처리 중 오류가 발생했습니다: ${error.message}`,
                    senderId: 'system',
                    timestamp: serverTimestamp()
                });
            }
        }

        leaveRoomBtn.addEventListener('click', async () => {
            if (unsubscribeMessages) unsubscribeMessages();
            if (unsubscribeTurnStatus) unsubscribeTurnStatus();

            if (currentRoomId && currentUser) {
                const turnStatusRef = doc(db, `chat_rooms/${currentRoomId}/turn_status`, 'current');
                await updateDoc(turnStatusRef, { participants: arrayRemove(currentUser.uid) });
            }

            currentRoomId = null; 
            chatMessages.innerHTML = ''; 
            chatRoom.classList.add('hidden'); 
            roomSelection.classList.remove('hidden'); 
            messageInput.disabled = false;
            sendBtn.disabled = false;
            sendBtn.textContent = '전송';
            gamePhase = 'statement1';
            gameRound = 1;
            isGameStarted = false;
        });

        function loadMessages(roomId) {
            const q = query(collection(db, `chat_rooms/${roomId}/messages`));
            unsubscribeMessages = onSnapshot(q, snapshot => {
                let messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                messages.sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));
                renderMessages(messages); 
            });
        }
        
        function updateGameStatus() {
            const phaseNames = {
                'statement1': '1차 진술',
                'discussion1': '1차 토론', 
                'statement2': '2차 진술',
                'discussion2': '2차 토론',
                'vote': '투표'
            };
            
            if (!isGameStarted) {
                gameStatus.textContent = '게임이 곧 시작됩니다. 메시지를 입력하면 AI들과 함께 라이어 게임이 시작됩니다!';
            } else {
                gameStatus.textContent = `현재 단계: ${phaseNames[gamePhase] || gamePhase} | 제시어: ${currentGameWord || '대기 중'}`;
            }
        }
        
        
        function renderSingleBubble(msgData, suspectIndex = -1) {
             const isMe = msgData.senderId === currentUser.uid;
             const isOperatorMessage = msgData.senderId === 'operator';
             const wrapper = document.createElement('div');
             wrapper.className = `flex ${isMe ? 'justify-end' : 'justify-start'} mb-3`;
             const container = document.createElement('div');
             
             // 이름 표시
             if (!isMe && msgData.senderId !== 'system') {
                 const senderName = document.createElement('p');
                 senderName.className = 'text-xs text-gray-500 dark:text-gray-400 mb-1 ml-3';
                 
                 if (isOperatorMessage && suspectIndex >= 0) {
                     // 운영자 메시지를 용의자 이름으로 표시
                     senderName.textContent = suspectNames[suspectIndex] || `용의자 ${suspectIndex + 1}`;
                 } else if (suspectIndex >= 0) {
                     // AI 메시지를 용의자 이름으로 표시
                     senderName.textContent = suspectNames[suspectIndex] || `용의자 ${suspectIndex + 1}`;
                 } else {
                     senderName.textContent = `사용자`;
                 }
                 container.appendChild(senderName);
             }
             
             const bubble = document.createElement('div');
             let bubbleClasses = 'max-w-md lg:max-w-lg px-4 py-3 rounded-2xl ';
             
             if (isMe) {
                 bubble.className = bubbleClasses + 'bg-blue-600 text-white';
             } else if (isOperatorMessage || suspectIndex >= 0) {
                 // 용의자들 (운영자 + AI)
                 bubble.className = bubbleClasses + 'bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 border border-purple-300 dark:border-purple-600';
             } else {
                 bubble.className = bubbleClasses + 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200';
             }
             
             bubble.textContent = msgData.text;
             container.appendChild(bubble);
             wrapper.appendChild(container);
             return wrapper;
        }

        function renderMessages(messages) {
            chatMessages.innerHTML = ''; 
            messages.forEach(msg => {
                if (msg.senderId === 'system') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex justify-center my-3';
                    const textDiv = document.createElement('div');
                    textDiv.className = 'text-xs text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-700 px-3 py-1 rounded-full';
                    textDiv.textContent = msg.text;
                    wrapper.appendChild(textDiv);
                    chatMessages.appendChild(wrapper);
                } else if (msg.type === 'all_responses' && msg.responses) {
                    // 모든 응답들을 그룹으로 표시
                    const roundWrapper = document.createElement('div');
                    roundWrapper.className = 'border-l-4 border-purple-400 pl-4 my-4 py-2 bg-purple-50 dark:bg-purple-900 rounded-r-lg';
                    
                    const phaseTitle = document.createElement('div');
                    phaseTitle.className = 'text-sm font-semibold text-purple-700 dark:text-purple-300 mb-2';
                    phaseTitle.textContent = msg.phaseTitle || '용의자들의 답변';
                    roundWrapper.appendChild(phaseTitle);
                    
                    msg.responses.forEach((response, index) => {
                        const responseMsg = { 
                            text: response.text, 
                            senderId: response.isOperator ? 'operator' : 'ai'
                        };
                        roundWrapper.appendChild(renderSingleBubble(responseMsg, response.suspectIndex));
                    });
                    chatMessages.appendChild(roundWrapper);
                } else {
                     chatMessages.appendChild(renderSingleBubble(msg));
                }
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
            updateGameStatus();
        }
        
        // 사용자 질문 전송
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault(); 
            const messageText = messageInput.value.trim(); 
            if (!messageText) return;
            
            // 운영자는 질문을 할 수 없음
            if (isOperator) {
                showNotification('운영자는 질문을 할 수 없습니다.');
                return;
            }
            
            // UI 잠금
            messageInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.textContent = '처리 중...';
            
            try {
                console.log('사용자 질문 전송:', messageText);
                
                // 사용자 질문 추가
                await addDoc(collection(db, `chat_rooms/${currentRoomId}/messages`), {
                    text: messageText,
                    senderId: currentUser.uid,
                    timestamp: serverTimestamp()
                });
                
                messageInput.value = '';
                console.log('사용자 질문 저장 완료');
                
                // 게임 턴 처리
                console.log('게임 턴 처리 시작...');
                await processGameTurn(messageText);
                console.log('게임 턴 처리 완료');
                
            } catch (error) {
                console.error("질문 전송 오류: ", error);
                showNotification("질문 전송에 실패했습니다.");
            } finally {
                // UI 잠금 해제
                messageInput.disabled = false;
                sendBtn.disabled = false;
                sendBtn.textContent = '질문';
                console.log('UI 잠금 해제 완료');
            }
        });
        
        // 운영자 답변 전송
        operatorForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const responseText = operatorMessageInput.value.trim();
            if (!responseText || !waitingForOperatorResponse) return;
            
            operatorMessageInput.disabled = true;
            operatorSendBtn.disabled = true;
            operatorSendBtn.textContent = '전송 중...';
            
            try {
                // 최신 temp_responses 찾기
                const tempQuery = query(
                    collection(db, `chat_rooms/${currentRoomId}/temp_responses`),
                    orderBy('timestamp', 'desc'),
                    limit(1)
                );
                const tempSnapshot = await getDocs(tempQuery);
                
                if (!tempSnapshot.empty) {
                    const tempDoc = tempSnapshot.docs[0];
                    const tempData = tempDoc.data();
                    
                    // 운영자 답변으로 업데이트
                    const updatedResponses = tempData.responses.map(response => {
                        if (response.isOperator && response.suspectIndex === operatorSuspectIndex) {
                            return { ...response, text: responseText };
                        }
                        return response;
                    });
                    
                    // 최종 응답 저장
                    await addDoc(collection(db, `chat_rooms/${currentRoomId}/messages`), {
                        type: 'all_responses',
                        responses: updatedResponses,
                        phaseTitle: tempData.phaseTitle,
                        timestamp: serverTimestamp()
                    });
                    
                    // 임시 데이터 삭제
                    await deleteDoc(tempDoc.ref);
                    
                    waitingForOperatorResponse = false;
                    operatorMessageInput.value = '';
                    operatorMessageInput.placeholder = '운영자로서 답변을 입력하세요...';
                }
                
            } catch (error) {
                console.error('운영자 답변 전송 오류:', error);
                showNotification('답변 전송에 실패했습니다.');
            } finally {
                operatorMessageInput.disabled = false;
                operatorSendBtn.disabled = false;
                operatorSendBtn.textContent = '전송';
            }
        });
        
        // --- [수정] 확률적으로 고양이 모습 바꾸기 기능 ---
        const catEmojiElement = document.getElementById('cat-emoji');
        // [수정] 업로드된 이미지를 Base64 데이터 URL로 변환하여 변수에 저장합니다.
        const specialCatImageUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAUoSURBVHhe7VtdiFVVFL7v2+lu1VOzBjPMMsPSChIiiCBEsiiyoKIvCl0oF6GuhUIXgghZFgU9iIgiA9EDpdFFL0UXQW9EEARdKEPYDBKkZ5Znpudk+5x7Du/M2b177z1z9jrnwz8+955zfp9zZ87ce885gP+nEaE0IZQmBNmE0L1YhNCkI5QmBNmE0IZQm3BCaEKoTQhNCK3b9GkQghC+ZgihS0M0J9S2QmiD0DQhNCeEMgStEELrhNCG0Lq2CeH5IQQhNCeE2oRQE6E/QmhC+LgQmvB/DkL//xGhtCEAixAaFrRACG0IgRCaFkIQ+hAaF95fEIIQEIIQIX+FEKGEEEIIO/gqhBCChBAhhBDyP1aE0A9DCEKEEEKkEMJEiP5NCM2TUIQQqoS+b8I8CEEIdQn9N+F5IQQhtCW0bhuE0H8hhCB0CU3D8I4QhC7B9+UhhC6FaUIoTRBC6ED4g+A3QgghdOENJIT6NwhBuCF+EELvQmhDtA6aELoTWhOEc0LoIghBCH0LzRAaLwSBkBBChBCChBC6EKqEEELrRAjNCaENQTehH4TGE4QQ+lG4Bf1iA6GEEHpHCKE9IdQhdCdUCCE0ZwhdaDwhdBe0TQj9IBQhhBC6EKoTQm1CuAl9ILwEIdQndC8mEEIIpQmhJkL3YhdC/1+BEEI3Qm1CeCGEEEIIofcMhNCb0A+hG0JnQmk6aEIIIYReL0I/hDaE2oReEMpGCCA0TQjVCH0f6kJ4hRBC6AWhG4TGEyGEEMITQoh+IYSwhhBCEELvWwh9CM0QRQjVCOEN4ReFEILQnaAThDaEegidCSGEEGoThNC88B6E0AQhBCGEGkJoTohGhNCGkJkQ+iHEaRBCv8bK0P+9CEEIMYQQQohQQghBCH3/4J8IoQuhH0LrhNAsEKGEEELrE0JoQ/gjhC6FNoReEJoQ+kEIIYReEELoTaggdCe0RgghhDaE7oTwhRBC6EIIIfQnhNCG0BWhYUKoQwhB6EKIGkJrQmhDtA6EEEJnQj9Ebwj9EIQQQmhC6ET4x34BfLwQeucn9L+JEEKIGkIIIYQQQk2EEMITwvc/CCHk4EEIIYRehRBC6EH4d3whhLCE/jfw6EEIIYQQwveL/QQIoQkhQghBuCFCCCEIIYQQQgiBWBBCEIIQPnwhhJATQk2EEELrRAghhNCb0JoQmhBCEMIIpQmhCYFGEEIIQeghhLCEEGIIQQhdCP+fA0JrhRBCCH0Q/l8LhBCaEIIIIdQhdCM0Rwh9CF0JpQmBH0IIIfSjUIII/RehCaEThRBCaED4/x4IoQkhQgi1CaEToR/Ck4MQghBCaEJ4Twh9EMIQohOEEEIIQeha4D/WEIIIIdQhNCE0QwiNEULoTPhPGEIIofVCCCE0QxAhdCG0RgghhNAtEIII/QmhCaE74XlCCEEKIdQgNB+EEEJvhNCG0IXwdwgCofWCEEII3QnhF4TGE4RGEEI3QgghVCN8DUIoTRBCaEIQ2oEQQohQjRBCaIboRCghdCM8ryGEEEIpoUmhCaFNoQnB/RBC6EH4o1BCaEIIIbQmNCE0TQj9EIIQWhNCGUL7hRBCaEIIoRWhjRBCX4ReEIQQmtA/IYTGE0JnQm1CCEGIIAThhNCG0BoRQsOAECGE0AQhBKEToV+hDSEToXWhfSEMIUSNEEIIrReaEHpBCKE7oR8aBCH0o7+EECGEEIQQohGEEEIIpQkCEEIITQihCaEVQm1CaEDoG5/vX/30V5qgAAAAAElFTkSuQmCC";
        let isSpecialCatVisible = false; // 특별한 고양이가 보이는 중인지 추적하는 변수

        // [추가] 타이핑 시 0.1% 확률로 고양이 모습 바꾸기
        messageInput.addEventListener('input', () => {
            // 0.1% 확률(0.001)이고, 특별한 고양이가 아직 안보일 때
            if (Math.random() < 0.001 && !isSpecialCatVisible) {
                isSpecialCatVisible = true;
                
                // 특별한 고양이 이미지로 변경
                catEmojiElement.innerHTML = `<img src="${specialCatImageUrl}" alt="special cat" class="w-12 h-12">`;

                // 5초 후에 다시 원래 이모지로 되돌림
                setTimeout(() => {
                    catEmojiElement.innerHTML = '🐈';
                    isSpecialCatVisible = false;
                }, 5000); // 5초
            }
        });

        const catNameElement = document.getElementById('cat-name');
        const names = ["이*혁", "고*건", "송*훈", "최*준", "한*상", "박*원", "이*수", "이*영", "트라라라라라라"];
        const randomName = names[Math.floor(Math.random() * names.length)];
        catNameElement.textContent = randomName;
        
    </script>
</body>
</html>