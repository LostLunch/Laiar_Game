<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 채팅</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; }
        #chat-messages::-webkit-scrollbar { width: 8px; }
        #chat-messages::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        #chat-messages::-webkit-scrollbar-thumb:hover { background: #555; }
        #rolling-cat-container {
            position: fixed;
            bottom: 10px;
            left: 0;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: rollAcross 20s linear infinite;
        }
        #cat-emoji { 
            font-size: 40px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #cat-name {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 5px;
            white-space: nowrap;
        }
        @keyframes rollAcross {
            0% { transform: translateX(-100px) rotate(0deg); }
            100% { transform: translateX(100vw) rotate(1800deg); }
        }
    </style>
</head>
<body class="bg-white flex items-center justify-center min-h-screen">
    <div class="w-full max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-gray-50 border border-gray-200 rounded-2xl shadow-lg p-6 flex flex-col h-[90vh] max-h-[900px]">

            <!-- 로그인 화면 -->
            <div id="login-screen" class="flex flex-col items-center justify-center h-full">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">로그인</h1>
                <p class="text-gray-600 mb-8 text-center">계정에 로그인하세요.</p>
                <div class="w-full max-w-sm flex flex-col items-center gap-4">
                    <input id="login-email-input" type="email" placeholder="이메일" class="w-full p-3 bg-gray-100 border border-gray-300 rounded-lg text-center" />
                    <input id="login-password-input" type="password" placeholder="비밀번호" class="w-full p-3 bg-gray-100 border border-gray-300 rounded-lg text-center" />
                    <button id="login-btn" class="w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">로그인</button>
                    <div class="my-2 flex items-center w-full"><hr class="w-full border-gray-300"><span class="px-4 text-gray-500 text-sm">또는</span><hr class="w-full border-gray-300"></div>
                    <button id="guest-login-btn" class="w-full px-6 py-3 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600">게스트로 로그인</button>
                    <p class="text-sm text-gray-600 mt-4">
                        계정이 없으신가요? <button id="go-to-signup-btn" class="font-semibold text-blue-600 hover:underline">회원가입</button>
                    </p>
                </div>
            </div>

            <!-- 회원가입 화면 -->
            <div id="signup-screen" class="hidden flex-col items-center justify-center h-full">
                <h1 class="text-3xl font-bold text-gray-900 mb-4">회원가입</h1>
                <p class="text-gray-600 mb-8 text-center">새로운 계정을 만드세요.</p>
                <div class="w-full max-w-sm flex flex-col items-center gap-4">
                    <input id="signup-email-input" type="email" placeholder="이메일" class="w-full p-3 bg-gray-100 border border-gray-300 rounded-lg text-center" />
                    <input id="signup-password-input" type="password" placeholder="비밀번호" class="w-full p-3 bg-gray-100 border border-gray-300 rounded-lg text-center" />
                    <button id="signup-btn" class="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">회원가입</button>
                     <p class="text-sm text-gray-600">
                        이미 계정이 있으신가요? <button id="go-to-login-btn" class="font-semibold text-blue-600 hover:underline">로그인</button>
                    </p>
                </div>
            </div>


            <!-- 방 선택 화면 -->
            <div id="room-selection" class="hidden flex-col items-center justify-center h-full">
                <h1 class="text-3xl font-bold text-gray-900 mb-2">실시간 채팅</h1>
                 <div id="user-info" class="text-center mb-6">
                    <p class="text-sm text-gray-600"><span id="user-email-display"></span>님 환영합니다!</p>
                    <div class="flex gap-4 justify-center">
                        <button id="logout-btn" class="text-xs text-red-500 hover:underline">로그아웃</button>
                        <button id="user-management-btn" class="text-xs text-purple-600 hover:underline">사용자 관리</button>
                    </div>
                </div>
                <p class="text-gray-600 mb-8 text-center">친구와 대화를 시작해보세요.</p>
                <div class="w-full max-w-sm flex flex-col items-center gap-4">
                    <div class="w-full">
                        <label for="room-id-input" class="block text-sm font-medium text-gray-700 mb-2 text-center">기존 방 참여하기 (ID 입력)</label>
                        <div class="flex gap-2">
                            <input id="room-id-input" type="text" placeholder="방 ID를 입력하세요" class="flex-1 p-3 bg-gray-100 border border-gray-300 rounded-lg text-center"/>
                            <button id="join-existing-room-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">참여</button>
                        </div>
                    </div>
                    <div class="my-2 flex items-center w-full"><hr class="w-full border-gray-300"><span class="px-4 text-gray-500">또는</span><hr class="w-full border-gray-300"></div>
                    <button id="create-new-room-btn" class="hidden w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">새로운 방 만들기</button>
                
                    <div class="my-4 w-full">
                        <h3 class="text-center text-sm font-medium text-gray-700 mb-2">참여 가능한 방 목록</h3>
                        <div id="available-rooms-list" class="flex flex-col gap-2 max-h-40 overflow-y-auto p-2 bg-gray-100 rounded-lg">
                            <!-- Room buttons will be inserted here by JS -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- 사용자 관리 화면 -->
            <div id="user-management-panel" class="hidden flex-col h-full">
                <div class="flex justify-between items-center w-full mb-4">
                    <h1 class="text-3xl font-bold text-gray-900">사용자 관리</h1>
                    <button id="back-to-rooms-btn" class="text-sm text-blue-600 hover:underline">방 목록으로</button>
                </div>
                <p class="text-gray-600 mb-6">사용자 닉네임 및 비밀번호를 관리합니다.</p>
                <div id="user-list-management" class="flex-1 overflow-y-auto w-full bg-gray-100 p-4 rounded-lg">
                    <!-- User list will be rendered here -->
                </div>
            </div>

            <!-- 대화 주제 선택 화면 -->
            <div id="topic-selection" class="hidden flex-col items-center justify-center h-full">
                <h1 class="text-2xl font-bold text-gray-900 mb-6">당신은 시민입니다</h1>
                <div id="random-topic-display" class="mb-8 text-2xl text-center text-gray-700 bg-gray-100 px-8 py-4 rounded-lg">
                    <!-- JavaScript에 의해 주제가 채워집니다 -->
                </div>
                <button id="start-chat-btn" class="w-full max-w-xs px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700">채팅 시작하기</button>
            </div>

            <!-- 채팅방 화면 -->
            <div id="chat-room" class="hidden flex-1 flex-col min-h-0">
                <div class="mb-4">
                     <div class="grid grid-cols-3 items-center mb-2">
                        <div class="text-left">
                           <h1 class="text-3xl font-bold text-gray-900">채팅방</h1>
                        </div>
                        <div class="text-center col-span-1">
                           <p class="text-lg text-gray-600">직업 : 시민</span></p>
                           <!-- 서버에서 선택한 제시어(비밀 단어) 표시 -->
                           <p class="text-sm text-gray-500 mt-1">제시어: <span id="secret-word-display" class="font-semibold text-gray-700">-</span></p>
                        </div>
                        <div class="text-right">
                           <button id="leave-room-btn" class="text-sm text-red-500 hover:underline">나가기</button>
                        </div>
                     </div>
                    <p class="text-base text-gray-500 break-all">방 ID: <span id="room-id-display" class="font-mono"></span></p>
                    <p class="text-base text-gray-500 break-all">내 프로필: <span id="user-id-display" class="font-mono"></span></p>
                    <div id="participants-status" class="text-sm text-gray-500 mt-2 h-4"></div>
                </div>
                <div id="chat-messages" class="flex-1 overflow-y-auto bg-gray-100 p-4 rounded-lg mb-4 border border-gray-200"></div>
                <form id="message-form" class="flex items-center gap-3">
                    <input id="message-input" type="text" placeholder="메시지를 입력하세요..." autocomplete="off" class="flex-1 p-3 bg-white border border-gray-300 rounded-lg text-lg"/>
                    <button id="send-btn" type="submit" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">전송</button>
                </form>
            </div>
        </div>
    </div>
    
    <div id="rolling-cat-container">
        <div id="cat-name"></div>
        <div id="cat-emoji">🐈</div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, sendPasswordResetEmail, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove, runTransaction, where, getDocs, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDMgGwmlV9T8l0CPsMrJ8H0NrTTUNtSDMo",
            authDomain: "text-861c1.firebaseapp.com",
            projectId: "text-861c1",
            storageBucket: "text-861c1.firebasestorage.app",
            messagingSenderId: "521608830043",
            appId: "1:521608830043:web:5df3d118d76ca4562eb37e",
        };
        
        const loginScreen = document.getElementById('login-screen');
        const signupScreen = document.getElementById('signup-screen');
        const loginEmailInput = document.getElementById('login-email-input');
        const loginPasswordInput = document.getElementById('login-password-input');
        const signupEmailInput = document.getElementById('signup-email-input');
        const signupPasswordInput = document.getElementById('signup-password-input');
        const loginBtn = document.getElementById('login-btn');
        const signupBtn = document.getElementById('signup-btn');
        const guestLoginBtn = document.getElementById('guest-login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const goToSignupBtn = document.getElementById('go-to-signup-btn');
        const goToLoginBtn = document.getElementById('go-to-login-btn');
        const userEmailDisplay = document.getElementById('user-email-display');
        
        const roomSelection = document.getElementById('room-selection');
        const topicSelection = document.getElementById('topic-selection');
        const chatRoom = document.getElementById('chat-room');
        const userManagementPanel = document.getElementById('user-management-panel');
        const userManagementBtn = document.getElementById('user-management-btn');
        const backToRoomsBtn = document.getElementById('back-to-rooms-btn');
        const userListManagement = document.getElementById('user-list-management');

        const roomIdInput = document.getElementById('room-id-input');
        const joinExistingRoomBtn = document.getElementById('join-existing-room-btn');
        const createNewRoomBtn = document.getElementById('create-new-room-btn');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const roomIdDisplay = document.getElementById('room-id-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const chatMessages = document.getElementById('chat-messages');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const participantsStatus = document.getElementById('participants-status');
        const availableRoomsList = document.getElementById('available-rooms-list');
        const topicDisplay = document.getElementById('topic-display');
        const randomTopicDisplay = document.getElementById('random-topic-display');
        const startChatBtn = document.getElementById('start-chat-btn');
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const animals = [
            { emoji: '🐶', name: '멍멍이' },
            { emoji: '🐱', name: '야옹이' },
            { emoji: '🦊', name: '불여우' },
            { emoji: '🐻', name: '곰돌이' },
            { emoji: '🐼', name: '판다' },
            { emoji: '🐨', name: '코알라' }
        ];

        let currentUser = null, currentRoomId = null;
        let unsubscribeMessages = null, unsubscribeTurnStatus = null;
        let selectedTopic = null;
        let userAnimalProfile = null;
        let participantProfiles = {};
        let currentMessages = [];
        let roomListTimer = null;
        let isCurrentUserAdmin = false; // 현재 사용자가 관리자인지 여부
        let currentNameMapping = {};   // 현재 방의 이름 매핑 객체
        
        function showNotification(message, type = 'success', duration = 5000) {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
            notification.className = `fixed top-5 right-5 ${bgColor} text-white py-2 px-4 rounded-lg shadow-lg z-50`;
            notification.innerHTML = message;
            document.body.appendChild(notification);
            setTimeout(() => { notification.remove(); }, duration);
        }

        function shuffleArray(array) {
            let currentIndex = array.length, randomIndex;
            // 배열에 요소가 남아있는 동안
            while (currentIndex != 0) {
                // 남은 요소 중 하나를 선택
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                // 현재 요소와 교환
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }
        
        function listenToAvailableRooms() {
            if (roomListTimer) clearInterval(roomListTimer);

            const q = query(collection(db, 'chat_rooms'), where("isDeleted", "==", false));
            let currentRoomDocs = [];

            const renderRoomList = () => {
                availableRoomsList.innerHTML = '';
                const tenSecondsAgo = Date.now() - 10000;

                const roomsToRender = currentRoomDocs.filter(doc => {
                    const roomData = doc.data();
                    const participantCount = roomData.participantCount || 0;
                    if (participantCount > 0) {
                        return true;
                    }
                    if (roomData.emptySince) {
                        const emptyTime = roomData.emptySince.toMillis();
                        if (emptyTime > tenSecondsAgo) {
                            return true;
                        }
                    }
                    return false;
                });

                if (roomsToRender.length === 0) {
                    const noRoomsMessage = document.createElement('p');
                    noRoomsMessage.className = 'text-center text-gray-500 text-sm py-4';
                    noRoomsMessage.textContent = '현재 참여 가능한 방이 없습니다.';
                    availableRoomsList.appendChild(noRoomsMessage);
                    return;
                }

                roomsToRender.forEach(doc => {
                    const roomId = doc.id;
                    const roomContainer = document.createElement('div');
                    roomContainer.className = 'flex items-center gap-2 w-full';

                    const roomBtn = document.createElement('button');
                    roomBtn.className = 'flex-1 p-2 font-semibold rounded-lg bg-gray-200 text-gray-800 hover:bg-gray-300 transition-colors';
                    roomBtn.textContent = `${roomId}`;
                    roomBtn.addEventListener('click', () => showTopicSelectionScreen(roomId));
                    
                    roomContainer.appendChild(roomBtn);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'px-3 py-2 bg-red-500 text-white text-xs font-semibold rounded-lg hover:bg-red-600 transition-colors';
                    deleteBtn.textContent = '삭제';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteRoom(roomId);
                    });
                    roomContainer.appendChild(deleteBtn);
                    
                    availableRoomsList.appendChild(roomContainer);
                });
            };

            onSnapshot(q, (snapshot) => {
                currentRoomDocs = snapshot.docs;
                renderRoomList();
            }, (error) => {
                console.error("Error listening to available rooms:", error);
                showNotification("방 목록을 불러오는 데 실패했습니다.", "error");
            });
            
            roomListTimer = setInterval(renderRoomList, 1000);
        }
        
        async function deleteRoom(roomId) {
            console.log(`User requesting deletion for room: ${roomId}`);
            try {
                if (!currentUser) {
                     showNotification("로그인이 필요합니다.", "error");
                     return;
                }
                const adminRef = doc(db, "admins", currentUser.uid);
                const adminDoc = await getDoc(adminRef);
                if (!adminDoc.exists()) {
                    showNotification("방 삭제는 관리자만 가능합니다.", "error");
                    return;
                }

                const roomRef = doc(db, 'chat_rooms', roomId);
                await updateDoc(roomRef, { isDeleted: true });
                showNotification(`'${roomId}' 방에 대한 삭제를 요청했습니다.`, 'success');
            } catch (error) {
                console.error("Error requesting room deletion:", error);
                showNotification("방 삭제 요청에 실패했습니다.", "error");
            }
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                try {
                    const adminRef = doc(db, "admins", user.uid);
                    const adminDoc = await getDoc(adminRef);
                    const isUserAdmin = adminDoc.exists();
                    isCurrentUserAdmin = isUserAdmin;

                    if (isUserAdmin) {
                        createNewRoomBtn.classList.remove('hidden');
                        userManagementBtn.classList.remove('hidden');
                    } else {
                        createNewRoomBtn.classList.add('hidden');
                        userManagementBtn.classList.add('hidden');
                    }

                    const userRef = doc(db, 'users', user.uid);
                    const userDoc = await getDoc(userRef);

                    if (userDoc.exists()) {
                        userAnimalProfile = userDoc.data().animalProfile;
                    } else {
                        userAnimalProfile = animals[Math.floor(Math.random() * animals.length)];
                        await setDoc(userRef, {
                            email: user.email || 'guest',
                            animalProfile: userAnimalProfile,
                        });
                    }

                    userIdDisplay.textContent = `${userAnimalProfile.emoji} ${userAnimalProfile.name}`;
                    userEmailDisplay.textContent = user.isAnonymous ? "게스트" : user.email;

                    loginScreen.classList.add('hidden');
                    signupScreen.classList.add('hidden');
                    roomSelection.classList.remove('hidden');
                    roomSelection.classList.add('flex');
                    userManagementPanel.classList.add('hidden');

                    listenToAvailableRooms();
                } catch (error) {
                    console.error("Error during authentication state change:", error);
                    showNotification(`로그인 중 프로필/권한 확인 실패: ${error.message}`, "error");
                    signOut(auth);
                }
            } else {
                currentUser = null;
                if (roomListTimer) clearInterval(roomListTimer);
                loginScreen.classList.remove('hidden');
                loginScreen.classList.add('flex');
                signupScreen.classList.add('hidden');
                roomSelection.classList.add('hidden');
                chatRoom.classList.add('hidden');
                topicSelection.classList.add('hidden');
                userManagementPanel.classList.add('hidden');
            }
        });
        
        const lockUI = () => {
            messageInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.textContent = '대기 중...';
        };
        const unlockUI = () => {
            messageInput.disabled = false;
            sendBtn.disabled = false;
            sendBtn.textContent = '전송';
        };

        async function showTopicSelectionScreen(roomId) {
        currentRoomId = roomId;

        // 🔽 *** 2-1. [수정] Firestore가 아닌, "게임 설정 API"를 호출 *** 🔽
        try {
            // 1. [핵심] 백엔드의 "set_game_word" API를 호출합니다.
            // (이 호출로 백엔드의 전역 변수 current_word와 current_category가 설정됩니다)
            const resp = await fetch('http://localhost:5000/api/set_game_word', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json; charset=utf-8' }
            });
            
            if (!resp.ok) {
                throw new Error(`API Error: ${await resp.text()}`);
            }
            
            const data = await resp.json();
            
            // 2. 백엔드가 정해준 "카테고리"를 받아와 화면에 표시합니다.
            selectedTopic = data.category || '알 수 없음'; // 전역 변수에도 저장
            randomTopicDisplay.textContent = `카테고리: ${selectedTopic}`;
            
            // 3. (선택사항) Firestore turn_status에도 카테고리 기록
            try {
                const turnStatusRef = doc(db, `chat_rooms/${currentRoomId}/turn_status`, 'current');
                await setDoc(turnStatusRef, { topic: selectedTopic, word: null }, { merge: true });
            } catch (errSync) {
                console.warn('turn_status에 카테고리 기록 실패:', errSync);
            }

            // 4. 카테고리 선택 화면으로 전환
            roomSelection.classList.add('hidden'); // (ID가 room-list-panel일 수 있음)
            userManagementPanel.classList.add('hidden');
            topicSelection.classList.remove('hidden');
            topicSelection.classList.add('flex');
            
        } catch(error) {
            console.error("Error in showTopicSelectionScreen:", error);
            showNotification(`게임 설정 API 호출 중 오류 발생: ${error.message}`, "error");
        }
        // 🔼 *** 2-1. 수정 완료 *** 🔼
    }

        startChatBtn.addEventListener('click', () => {
            (async () => {
                if (!currentRoomId) return showNotification("방 ID가 없습니다.", "error");
                try {
                    const resp = await fetch('http://localhost:5000/api/start_dec', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json; charset=utf-8' }
                    });
                    if (!resp.ok) throw new Error(await resp.text());
                    const data = await resp.json();
                    
                    currentWord = data.word || null;
                    const secretEl = document.getElementById('secret-word-display');
                    if (secretEl) secretEl.textContent = currentWord || '-';

                   // ===== 동기화: 서버가 정한 제시어를 방의 turn_status에 기록 =====
                   try {
                       const turnStatusRef = doc(db, `chat_rooms/${currentRoomId}/turn_status`, 'current');
                       await updateDoc(turnStatusRef, { word: currentWord });
                   } catch (errSync) {
                       console.warn('turn_status에 제시어 기록 실패:', errSync);
                   }
                   // =======================================================

                    // 🔽 *** 수정된 부분 (1/2) *** 🔽
                    // 채팅방에 먼저 입장하여 chatMessages 엘리먼트가 준비되도록 합니다.
                    enterChatRoom(currentRoomId);
                    
                    // AI의 첫 번째 진술 메시지를 채팅창에 표시합니다.
                    if (data.declaration_messages && Array.isArray(data.declaration_messages)) {
                        // "진술" 라운드라는 것을 알리는 시스템 메시지 추가
                        const wrapper = document.createElement('div');
                        wrapper.className = 'flex justify-center my-3';
                        const textDiv = document.createElement('div');
                        textDiv.className = 'text-xs text-gray-500 bg-gray-200 px-3 py-1 rounded-full';
                        textDiv.textContent = '=== 1차 진술 시작 ===';
                        wrapper.appendChild(textDiv);
                        chatMessages.appendChild(wrapper); // chatMessages가 이제 사용 가능
                        
                        data.declaration_messages.forEach((msg, index) => {
                            // AI 프로필이 없으므로 'ai_X' ID를 사용
                            const aiBubble = renderSingleBubble({ text: msg, senderId: `ai_${index}` });
                            chatMessages.appendChild(aiBubble);
                        });
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                    
                    // "진술" 단계가 완료되었으므로, 다음 단계를 "토론"으로 설정합니다.
                    currentPhase = "토론"; 
                    // 🔼 *** 수정 완료 (1/2) *** 🔼

                    // enterChatRoom(currentRoomId); // ⬅️ 이 라인을 위로 이동시켰습니다.
                } catch (err) {
                    console.error('start_dec failed:', err);
                    showNotification('제시어를 불러오는 데 실패했습니다.', 'error');
                }
            })();
        });

        async function enterChatRoom(roomId) {
            topicSelection.classList.add('hidden');
            chatRoom.classList.remove('hidden'); 
            chatRoom.classList.add('flex');
            roomIdDisplay.textContent = roomId; 
            
            const roomRef = doc(db, 'chat_rooms', roomId);
            const turnStatusRef = doc(db, `chat_rooms/${roomId}/turn_status`, 'current');
            const userRef = doc(db, 'users', currentUser.uid);

            try {
                const turnStatusSnap = await getDoc(turnStatusRef);
                if (!turnStatusSnap.exists()) {
                    throw new Error("방 상태 정보를 찾을 수 없습니다.");
                }

                const turnData = turnStatusSnap.data();
                const currentProfilesInRoom = turnData.participantProfiles || {};
                const participants = turnData.participants || [];
                let finalUserAnimalProfile = userAnimalProfile;
                let profileChanged = false;

                const isProfileTakenByOther = Object.values(currentProfilesInRoom)
                    .some(profile => profile.name === userAnimalProfile.name);

                if (isProfileTakenByOther && !participants.includes(currentUser.uid)) {
                    profileChanged = true;
                    const usedAnimalNames = Object.values(currentProfilesInRoom).map(p => p.name);
                    const availableAnimals = animals.filter(a => !usedAnimalNames.includes(a.name));

                    if (availableAnimals.length > 0) {
                        finalUserAnimalProfile = availableAnimals[Math.floor(Math.random() * availableAnimals.length)];
                    } else {
                        finalUserAnimalProfile = animals[Math.floor(Math.random() * animals.length)];
                        showNotification("모든 프로필이 사용 중이라, 중복된 프로필이 할당될 수 있습니다.", "error");
                    }
                }

                await runTransaction(db, async (transaction) => {
                    const freshTurnDoc = await transaction.get(turnStatusRef);
                    if (!freshTurnDoc.exists()) throw new Error("방 상태 정보를 트랜잭션 중에 찾을 수 없습니다.");
                    
                    const freshParticipants = freshTurnDoc.data().participants || [];

                    if (!freshParticipants.includes(currentUser.uid)) {
                        const newParticipants = [...freshParticipants, currentUser.uid];
                        transaction.update(turnStatusRef, {
                            participants: newParticipants,
                            [`participantProfiles.${currentUser.uid}`]: finalUserAnimalProfile
                        });
                        transaction.update(roomRef, { 
                            participantCount: newParticipants.length,
                            emptySince: deleteField()
                        });
                    }
                    
                    if (profileChanged) {
                        transaction.update(userRef, { animalProfile: finalUserAnimalProfile });
                    }
                });
                
                if (profileChanged) {
                    userAnimalProfile = finalUserAnimalProfile;
                    userIdDisplay.textContent = `${userAnimalProfile.emoji} ${userAnimalProfile.name}`;
                    showNotification(`프로필이 중복되어 '${userAnimalProfile.name}'(으)로 변경되었습니다.`, 'success');
                }

            } catch (error) {
                 console.error("Error entering room:", error);
                 showNotification("방 입장에 실패했습니다.", 'error');
                 chatRoom.classList.add('hidden');
                 roomSelection.classList.remove('hidden');
                 return;
            }
            
            listenToTurnStatus(roomId);
            loadMessages(roomId);

            const messagesColPath = `chat_rooms/${currentRoomId}/messages`;
            await addDoc(collection(db, messagesColPath), {
                text: `${userAnimalProfile.emoji} ${userAnimalProfile.name}님이 입장했습니다.`,
                senderId: 'system',
                timestamp: serverTimestamp()
            });
        }


        joinExistingRoomBtn.addEventListener('click', async () => {
            const roomId = roomIdInput.value.trim(); 
            if (!roomId) return showNotification("방 ID를 입력해주세요.", 'error');
            try {
                const docSnap = await getDoc(doc(db, 'chat_rooms', roomId));
                if (docSnap.exists() && docSnap.data().isDeleted === false) {
                    await showTopicSelectionScreen(roomId);
                } else { 
                    showNotification("방을 찾을 수 없거나 삭제된 방입니다.", 'error');
                }
            } catch(error) {
                 console.error("Error joining room by ID:", error);
                showNotification("방 정보를 가져오는 데 실패했습니다.", 'error');
            }
        });

        createNewRoomBtn.addEventListener('click', async () => {
            const newRoomId = Math.random().toString(36).substring(2, 8);
            
                

            await setDoc(doc(db, 'chat_rooms', newRoomId), { 
                createdAt: serverTimestamp(),
                isDeleted: false,
                participantCount: 0
            });
            
            await setDoc(doc(db, `chat_rooms/${newRoomId}/turn_status`, 'current'), {
                topic: selectedTopic,
                participants: [],
                submissions: {},
                participantProfiles: {}
            });
            await showTopicSelectionScreen(newRoomId);
        });
        
        leaveRoomBtn.addEventListener('click', async () => {
            if (!currentRoomId || !currentUser) return;

            await addDoc(collection(db, `chat_rooms/${currentRoomId}/messages`), {
                text: `${userAnimalProfile.emoji} ${userAnimalProfile.name}님이 퇴장했습니다.`,
                senderId: 'system',
                timestamp: serverTimestamp()
            });

            const roomRef = doc(db, 'chat_rooms', currentRoomId);
            const turnStatusRef = doc(db, `chat_rooms/${currentRoomId}/turn_status`, 'current');
            
            try {
                await runTransaction(db, async (transaction) => {
                    const turnDoc = await transaction.get(turnStatusRef);
                    if (!turnDoc.exists()) return;

                    const turnData = turnDoc.data();
                    const participants = turnData.participants || [];
                    
                    const newParticipants = participants.filter(uid => uid !== currentUser.uid);
                    transaction.update(turnStatusRef, { participants: newParticipants });

                    if (newParticipants.length === 0) {
                        transaction.update(roomRef, {
                            participantCount: 0,
                            emptySince: serverTimestamp()
                        });
                    } else {
                        transaction.update(roomRef, {
                            participantCount: newParticipants.length
                        });
                    }
                });
            } catch (error) {
                console.error("Failed to leave room:", error);
                showNotification("방을 나가는 중 오류가 발생했습니다.", 'error');
            }

            if (unsubscribeMessages) unsubscribeMessages();
            if (unsubscribeTurnStatus) unsubscribeTurnStatus();

            currentRoomId = null; 
            chatMessages.innerHTML = ''; 
            currentMessages = []; 
            participantsStatus.textContent = '';
            chatRoom.classList.add('hidden'); 
            topicSelection.classList.add('hidden');
            roomSelection.classList.remove('hidden');
            listenToAvailableRooms();
            unlockUI();
        });

        function loadMessages(roomId) {
            const q = query(collection(db, `chat_rooms/${roomId}/messages`));
            unsubscribeMessages = onSnapshot(q, snapshot => {
                let messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                messages.sort((a, b) => (a.timestamp?.seconds || 0) - (b.timestamp?.seconds || 0));
                currentMessages = messages; 
                renderMessages(messages); 
            });
        }
        
        function listenToTurnStatus(roomId) {
            const turnStatusRef = doc(db, `chat_rooms/${roomId}/turn_status`, 'current');
            unsubscribeTurnStatus = onSnapshot(turnStatusRef, (docSnap) => {
                if (!docSnap.exists()) return;
                
                const turnData = docSnap.data();
                const submissions = turnData.submissions || {};
                const participants = turnData.participants || [];
                const newParticipantProfiles = turnData.participantProfiles || {};
                selectedTopic = turnData.topic; 

                // 서버/운영자가 설정한 제시어가 있으면 화면에 표시
                const secretEl = document.getElementById('secret-word-display');
                if (secretEl) {
                    secretEl.textContent = turnData.word || '-';
                    // 프론트 변수도 동기화
                    currentWord = turnData.word || currentWord;
                }

                if (JSON.stringify(participantProfiles) !== JSON.stringify(newParticipantProfiles)) {
                    participantProfiles = newParticipantProfiles;
                    if (currentMessages.length > 0) {
                        renderMessages(currentMessages);
                    }
                }

                topicDisplay.innerHTML = `<span class="font-semibold text-gray-700">${selectedTopic}</span>`;
                
                participantsStatus.textContent = `참가자: ${participants.length}명 | 제출 현황: ${Object.keys(submissions).length} / ${participants.length}`;

                if (submissions[currentUser.uid]) {
                    lockUI();
                } else {
                    unlockUI();
                }
            });
        }
        
        function renderSingleBubble(msgData, isRound = false) {
             const isMe = msgData.senderId === currentUser.uid;
             const wrapper = document.createElement('div');
             wrapper.className = `flex ${isMe ? 'justify-end' : 'justify-start'} ${isRound ? 'my-1' : 'mb-3'}`;
             
             const container = document.createElement('div');
             
             const senderProfile = participantProfiles[msgData.senderId] || (isMe ? userAnimalProfile : { emoji: '👤', name: '익명' });
    
             const senderName = document.createElement('p');
             senderName.className = `text-xs text-gray-500 mb-1 ${isMe ? 'text-right mr-3' : 'ml-3'}`;
             senderName.textContent = `${senderProfile.emoji} ${senderProfile.name}`;
             container.appendChild(senderName);

             const bubble = document.createElement('div');
             let bubbleClasses = 'max-w-md lg:max-w-lg px-4 py-3 rounded-2xl text-lg ';
             bubble.className = bubbleClasses + (isMe ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-800');
             bubble.textContent = msgData.text;
             
             container.appendChild(bubble);
             wrapper.appendChild(container);
             return wrapper;
        }

        function renderMessages(messages) {
            chatMessages.innerHTML = ''; 
            messages.forEach(msg => {
                if (msg.senderId === 'system') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'flex justify-center my-3';
                    const textDiv = document.createElement('div');
                    textDiv.className = 'text-xs text-gray-500 bg-gray-200 px-3 py-1 rounded-full';
                    textDiv.textContent = msg.text;
                    wrapper.appendChild(textDiv);
                    chatMessages.appendChild(wrapper);
                } else if (msg.type === 'round' && msg.roundData) {
                    const roundWrapper = document.createElement('div');
                    roundWrapper.className = 'border-l-2 border-gray-300 pl-3 my-4 py-2';
                    msg.roundData.forEach(roundMsg => {
                        roundWrapper.appendChild(renderSingleBubble(roundMsg, true));
                    });
                    chatMessages.appendChild(roundWrapper);
                } else {
                     chatMessages.appendChild(renderSingleBubble(msg));
                }
            });
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // 백엔드의 AI 응답 생성 엔드포인트를 호출하는 함수
        // 라운드 상태 추적용 (초기값은 진술)
        let currentPhase = "진술";
        let currentWord = null;

        // 백엔드의 AI 응답 생성 엔드포인트를 호출하는 함수
        async function sendMessageToAI(userMessage) {
            try {
                // 🔽 *** 수정된 부분 *** 🔽
                // 모든 AI 응답 요청을 /api/ai_response 엔드포인트로 통일합니다.
                // /api/start_dec는 startChatBtn에서만 호출하도록 변경되었습니다.
                // currentWord는 백엔드 서버에 저장된 값을 사용하므로 보낼 필요가 없습니다.

                const endpoint = "http://localhost:5000/api/ai_response";
                const bodyData = { 
                    prompt: userMessage,  // 사용자의 채팅 메시지
                    phase: currentPhase   // 현재 게임 단계 (예: "토론")
                };
                
                // 🔼 *** (이전 if/else 로직 삭제) *** 🔼

                const response = await fetch(endpoint, {
                    method: "PATCH",
                    headers: {
                        "Content-Type": "application/json; charset=utf-8"
                    },
                    body: JSON.stringify(bodyData)
                });

                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${await response.text()}`);
                }

                const data = await response.json();

                // 🔽 *** 수정된 부분 *** 🔽
                // /api/ai_response는 항상 "ai_response" 키로 응답합니다.
                
                if (data.word) {
                    // (참고) 응답에 word가 포함되어 오지만, 
                    // 이미 startChatBtn에서 설정했으므로 여기서 갱신할 필요는 없습니다.
                    currentWord = data.word; 
                }

                let aiResponse = null;

                if (data.ai_response) {
                    aiResponse = data.ai_response;
                } else {
                    // 예외 처리: 혹시 모를 다른 형식의 응답
                    console.warn("AI 응답이 'ai_response' 키에 없습니다.", data);
                    return null;
                }
                
                // 🔼 *** (이전 declaration_messages 등 처리 로직 삭제) *** 🔼

                return aiResponse;
            } catch (error) {
                console.error("Failed to fetch AI response:", error);
                return null;
            }
        }


        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            
            // 사용자 메시지를 채팅창에 추가
            const userBubble = renderSingleBubble({ text: userMessage, senderId: currentUser.uid });
            chatMessages.appendChild(userBubble);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            messageInput.value = ''; // 입력창 비우기

            // 2. 백엔드 AI에게 응답 요청
            const aiResponse = await sendMessageToAI(userMessage);

            // 3. (AI) 응답을 Firestore에 "저장"만 합니다. (렌더링 X)
            // 🔽 *** [수정] 이 블록 전체를 수정합니다 *** 🔽
            if (aiResponse && Array.isArray(aiResponse)) {
                
                // (이전 코드: aiResponse.forEach(msg, index) => { ...)
                
                // 4. (AI) 응답을 화면에 *수동으로* 렌더링 ⬅️ [삭제]
                // const aiBubble = renderBubble(senderId, [{ text: msg }], false);
                // chatMessages.appendChild(aiBubble); ⬅️ [삭제] 이 줄을 삭제합니다.

                // 5. (AI) 응답 4개를 각각 Firestore에 "저장"만 합니다.
                // 렌더링은 onSnapshot이 알아서 할 것입니다.
                try {
                    aiResponse.forEach((msg, index) => {
                        const senderId = `ai_${index}`;
                        addDoc(messagesRef, {
                            text: msg,
                            senderId: senderId,
                            createdAt: serverTimestamp()
                        });
                    });
                } catch (err) {
                    console.error("Firestore에 AI 응답 저장 실패:", err);
                }
                
                // [참고] 스크롤 로직은 onSnapshot 안으로 이동했으므로 여기서 필요 없습니다.
                // chatMessages.scrollTop = chatMessages.scrollHeight; ⬅️ [삭제]

            } else {
                showNotification("AI 응답을 가져오는 데 실패했습니다.", "error");
            }
            // 🔼 *** [수정] 완료 *** 🔼
        });
        
        signupBtn.addEventListener('click', async () => {
            const email = signupEmailInput.value;
            const password = signupPasswordInput.value;
            if (!email || !password) {
                return showNotification("이메일과 비밀번호를 모두 입력해주세요.", "error");
            }
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                showNotification("회원가입 성공! 자동으로 로그인됩니다.", "success");
            } catch (error) {
                showNotification(`회원가입 실패: ${error.message}`, "error");
            }
        });

        loginBtn.addEventListener('click', async () => {
            const email = loginEmailInput.value;
            const password = loginPasswordInput.value;
             if (!email || !password) {
                return showNotification("이메일과 비밀번호를 모두 입력해주세요.", "error");
            }
            try {
                await signInWithEmailAndPassword(auth, email, password);
                 showNotification("로그인 성공!", "success");
            } catch (error) {
                 showNotification(`로그인 실패: ${error.message}`, "error");
            }
        });
        
        guestLoginBtn.addEventListener('click', async () => {
            try {
                await signInAnonymously(auth);
                showNotification("게스트로 로그인 성공!", "success");
            } catch (error) {
                showNotification(`게스트 로그인 실패: ${error.message}`, "error");
            }
        });

        logoutBtn.addEventListener('click', async () => {
            try {
                await signOut(auth);
                showNotification("로그아웃 되었습니다.", "success");
            } catch (error) {
                 showNotification(`로그아웃 실패: ${error.message}`, "error");
            }
        });

        goToSignupBtn.addEventListener('click', () => {
            loginScreen.classList.add('hidden');
            loginScreen.classList.remove('flex');
            signupScreen.classList.remove('hidden');
            signupScreen.classList.add('flex');
        });

        goToLoginBtn.addEventListener('click', () => {
            signupScreen.classList.add('hidden');
            signupScreen.classList.remove('flex');
            loginScreen.classList.remove('hidden');
            loginScreen.classList.add('flex');
        });

        userManagementBtn.addEventListener('click', () => {
            roomSelection.classList.add('hidden');
            userManagementPanel.classList.remove('hidden');
            userManagementPanel.classList.add('flex');
            loadAndRenderUsers();
        });

        backToRoomsBtn.addEventListener('click', () => {
            userManagementPanel.classList.add('hidden');
            roomSelection.classList.remove('hidden');
            roomSelection.classList.add('flex');
        });

        async function loadAndRenderUsers() {
            userListManagement.innerHTML = '<p>사용자 목록 로딩중...</p>';
            try {
                const usersCol = collection(db, 'users');
                const userSnapshot = await getDocs(usersCol);
                
                userListManagement.innerHTML = '';

                if (userSnapshot.empty) {
                     userListManagement.innerHTML = '<p>등록된 사용자가 없습니다.</p>';
                     return;
                }

                userSnapshot.forEach(userDoc => {
                    const userData = userDoc.data();
                    const userId = userDoc.id;

                    const userDiv = document.createElement('div');
                    userDiv.className = 'p-3 mb-2 bg-white rounded-lg shadow-sm flex items-center justify-between';

                    const userInfoDiv = document.createElement('div');
                    const userEmailText = (userData.email === 'guest' || !userData.email) ? '게스트 계정' : userData.email;
                    userInfoDiv.innerHTML = `
                        <p class="text-sm font-semibold">${userEmailText}</p>
                        <p class="text-xs text-gray-600">현재 닉네임: ${userData.animalProfile.emoji} ${userData.animalProfile.name}</p>
                    `;

                    const userActionDiv = document.createElement('div');
                    userActionDiv.className = 'flex items-center gap-2';

                    const newNameSelect = document.createElement('select');
                    newNameSelect.className = 'p-1 border rounded text-sm';
                    animals.forEach(animal => {
                        const option = document.createElement('option');
                        option.value = animal.name;
                        option.textContent = `${animal.emoji} ${animal.name}`;
                        if (animal.name === userData.animalProfile.name) {
                            option.selected = true;
                        }
                        newNameSelect.appendChild(option);
                    });

                    const saveBtn = document.createElement('button');
                    saveBtn.textContent = '저장';
                    saveBtn.className = 'px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600';
                    saveBtn.onclick = async () => {
                        const newName = newNameSelect.value;
                        const newProfile = animals.find(a => a.name === newName);
                        if (newProfile) {
                            await updateUserNickname(userId, newProfile);
                            loadAndRenderUsers(); // 목록 새로고침
                        }
                    };
                    
                    userActionDiv.appendChild(newNameSelect);
                    userActionDiv.appendChild(saveBtn);

                    if (userData.email && userData.email !== 'guest') {
                        const resetPasswordBtn = document.createElement('button');
                        resetPasswordBtn.textContent = '비밀번호 재설정';
                        resetPasswordBtn.className = 'px-2 py-1 bg-orange-500 text-white text-xs rounded hover:bg-orange-600';
                        resetPasswordBtn.onclick = () => {
                            sendPasswordReset(userData.email);
                        };
                        userActionDiv.appendChild(resetPasswordBtn);
                    }
                    
                    userDiv.appendChild(userInfoDiv);
                    userDiv.appendChild(userActionDiv);

                    userListManagement.appendChild(userDiv);
                });
            } catch(error) {
                console.error("Error loading users:", error);
                userListManagement.innerHTML = '<p class="text-red-500">사용자 목록을 불러오는 데 실패했습니다.</p>';
                showNotification("사용자 목록을 불러오는 데 실패했습니다.", "error");
            }
        }

        async function updateUserNickname(userId, newProfile) {
            try {
                const userRef = doc(db, 'users', userId);
                await updateDoc(userRef, { animalProfile: newProfile });
                showNotification("닉네임이 업데이트되었습니다.", "success");
            } catch (error) {
                console.error("Error updating nickname:", error);
                showNotification("닉네임 업데이트에 실패했습니다.", "error");
            }
        }
        
        async function sendPasswordReset(email) {
            try {
                await sendPasswordResetEmail(auth, email);
                showNotification(`${email}으로 비밀번호 재설정 이메일을 보냈습니다.`, "success");
            } catch (error) {
                console.error("Error sending password reset email:", error);
                showNotification("비밀번호 재설정 이메일 전송에 실패했습니다.", "error");
            }
        }


        const catEmojiElement = document.getElementById('cat-emoji');
        const specialCatImageUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAUoSURBVHhe7VtdiFVVFL7v2+lu1VOzBjPMMsPSChIiiCBEsiiyoKIvCl0oF6GuhUIXgghZFgU9iIgiA9EDpdFFL0UXQW9EEARdKEPYDBKkZ5Znpudk+5x7Du/M2b1r7z1z9jrnwz8+955zfp9zZ87ce885gP+nEaE0IZQmBNmE0L1YhNCkI5QmBNmE0IZQm3BCaEKoTQhNCK3b9GkQghC+ZgihS0M0J9S2QmiD0DQhNCeEMgStEELrhNCG0Lq2CeH5IQQhNCeE2oRQE6E/QmhC+LgQmvB/DkL//xGhtCEAixAaFrRACG0IgRCaFkIQ+hAaF95fEIIQEIIQIX+FEKGEEEIIO/gqhBCChBAhhBDyP1aE0A/DCEKEEEKkEMJEiP5NCM2TUIQQqoS+b8I8CEEIdQn9N+F5IQQhtCW0bhuE0H8hhCB0CU3D8I4QhC7B9+UhhC6FaUIoTRBC6ED4g+A3QgghdOENJIT6NwhBuCF+EELvQmhDtA6aELoTWhOEc0LoIghBCH0LzRAaLwSBkBBChBCChBC6EKqEEELrRAjNCaENQTehH4TGE4QQ+lG4Bf1iA6GEEHpHCKE9IdQhdCdUCCE0ZwhdaDwhdBe0TQj9IBQhhBC6EKoTQm1CuAl9ILwEIdQndC8mEEIIpQmhJkL3YhdC/1+BEEI3Qm1CeCGEEEIIofcMhNCb0A+hGTOCAgAASURBVG0JnQmk6aEIIIYReL0I/hDaE2oReEMpGCCA0TQjVCH0f6kJ4hRBC6AWhG4TGEyGEEMITQoh+IYSwhhBCEELvWwh9CM0QRQjVCOEN4ReFEILQnaAThDaEegidCSGEEGoThNC88B6E0AQhBCGEGkJoTohGhNCGkJkQ+iHEaRBCv8bK0P+9CEEIMYQQQohQQghBCH3/4J8IoQuhH0LrhNAsEKGEEELrE0JoQ/gjhC6FNoReEJoQ+kEIIYReEELoTaggdCe0RgghhDaE7oTwhRBC6EIIIfQnhNCG0BWhYUKoQwhB6EKIGkJrQmhDtA6EEEJnQj9Ebwj9EIQQQmhC6ET4x34BfLwQeucn9L+JEEKIGkIIIYQQQk2EEMITwvc/CCHk4EEIIYRehRBC6EH4d3whhLCE/jfw6EEIIYQQwveL/QQIoQkhQghBuCFCCCEIIYQQQgiBWBBCEIIQPnwhhJATQk2EEELrRAghhNCb0JoQmhBCEMIIpQmhCYFGEEIIQeghhLCEEGIIQQhdCP+fA0JrhRBCCH0Q/l8LhBCaEIIIIdQhdCM0Rwh9CF0JpQmBH0IIIfSjUIII/RehCaEThRBCaEDoG5/vX/0V5qgAAAAAElFTuQmCC";
        let isSpecialCatVisible = false;

        messageInput.addEventListener('input', () => {
            if (Math.random() < 0.001 && !isSpecialCatVisible) {
                isSpecialCatVisible = true;
                catEmojiElement.innerHTML = `<img src="${specialCatImageUrl}" alt="special cat" class="w-12 h-12">`;
                setTimeout(() => {
                    catEmojiElement.innerHTML = '🐈';
                    isSpecialCatVisible = false;
                }, 5000);
            }
        });

        const catNameElement = document.getElementById('cat-name');
        const names = ["이*혁", "고*건", "송*훈", "최*준", "한*상", "박*원", "이*수", "이*영", "트라라라라라라"];
        const randomName = names[Math.floor(Math.random() * names.length)];
        catNameElement.textContent = randomName;
        
    </script>
</body>
</html>

